"""
Text file export functionality for solve data.
"""

import time
from typing import Dict, Any, List, Optional
from ..core.cube_state import CubeState
from ..core.moves import MoveSequence
from ..core.color_scheme import ColorScheme


def export_txt(filename: str,
               start_state: CubeState,
               sequence: MoveSequence,
               stats: Dict[str, Any],
               color_scheme: ColorScheme = None,
               notes: List[str] = None) -> None:
    """
    Export solve data to text format.
    
    Args:
        filename: Output text filename
        start_state: Initial cube state
        sequence: Solution move sequence
        stats: Solve statistics
        color_scheme: Color scheme used
        notes: Optional tutorial notes
    """
    if color_scheme is None:
        color_scheme = ColorScheme()
    
    with open(filename, 'w', encoding='utf-8') as f:
        # Header
        f.write("=" * 60 + "\n")
        f.write("CUBIST - RUBIK'S CUBE SOLUTION REPORT\n")
        f.write("=" * 60 + "\n\n")
        
        # Basic information
        f.write("SOLVE INFORMATION\n")
        f.write("-" * 20 + "\n")
        f.write(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Solver: {stats.get('solver', 'Unknown')}\n")
        f.write(f"Total Moves: {len(sequence)}\n")
        f.write(f"Solve Time: {_format_time(stats.get('time', 0.0))}\n")
        f.write(f"TPS (Turns/sec): {stats.get('tps', 0.0):.2f}\n")
        f.write("\n")
        
        # Solution moves
        f.write("SOLUTION MOVES\n")
        f.write("-" * 20 + "\n")
        if len(sequence) == 0:
            f.write("No moves required - cube is already solved!\n")
        else:
            # Format moves in lines of reasonable length
            moves_str = str(sequence)
            f.write(_wrap_text(moves_str, 70))
        f.write("\n\n")
        
        # Detailed move breakdown
        if len(sequence) > 0:
            f.write("MOVE BREAKDOWN\n")
            f.write("-" * 20 + "\n")
            f.write(f"{'Step':<4} {'Move':<4} {'Description':<30}\n")
            f.write("-" * 50 + "\n")
            
            for i, move in enumerate(sequence.moves):
                description = _get_move_description(str(move))
                f.write(f"{i+1:<4} {str(move):<4} {description:<30}\n")
            f.write("\n")
        
        # Move analysis
        f.write("MOVE ANALYSIS\n")
        f.write("-" * 20 + "\n")
        analysis = _analyze_moves(sequence)
        
        f.write("Face Distribution:\n")
        for face, count in analysis['face_counts'].items():
            percentage = (count / len(sequence)) * 100 if len(sequence) > 0 else 0
            f.write(f"  {face}: {count} moves ({percentage:.1f}%)\n")
        f.write("\n")
        
        f.write("Move Types:\n")
        f.write(f"  Quarter turns: {analysis['quarter_turns']}\n")
        f.write(f"  Half turns: {analysis['half_turns']}\n")
        f.write("\n")
        
        # Tutorial notes
        if notes:
            f.write("TUTORIAL NOTES\n")
            f.write("-" * 20 + "\n")
            for i, note in enumerate(notes, 1):
                f.write(f"{i}. {note}\n")
            f.write("\n")
        
        # Color scheme information
        f.write("COLOR SCHEME\n")
        f.write("-" * 20 + "\n")
        scheme_dict = color_scheme.to_dict()
        for face, color in scheme_dict.items():
            f.write(f"{face} (Up/Down/Front/Back/Right/Left): {color}\n")
        f.write("\n")
        
        # Cube state information
        f.write("CUBE STATE DETAILS\n")
        f.write("-" * 20 + "\n")
        f.write("Initial State:\n")
        f.write(f"  Solved: {start_state.is_solved()}\n")
        
        final_state = sequence.apply_to(start_state)
        f.write("Final State:\n")
        f.write(f"  Solved: {final_state.is_solved()}\n")
        f.write("\n")
        
        # Statistics summary
        f.write("STATISTICS SUMMARY\n")
        f.write("-" * 20 + "\n")
        f.write(f"Algorithm Efficiency: {_rate_efficiency(len(sequence))}\n")
        f.write(f"Execution Speed: {_rate_speed(stats.get('tps', 0.0))}\n")
        f.write(f"Overall Rating: {_overall_rating(len(sequence), stats.get('tps', 0.0))}\n")
        f.write("\n")
        
        # Footer
        f.write("=" * 60 + "\n")
        f.write("Generated by Cubist - 3×3 Rubik's Cube Solver & Tutor\n")
        f.write("Visit our website for more solving tools and tutorials\n")
        f.write("=" * 60 + "\n")


def _format_time(seconds: float) -> str:
    """Format time in MM:SS.ss format."""
    minutes = int(seconds // 60)
    seconds = seconds % 60
    return f"{minutes:02d}:{seconds:05.2f}"


def _wrap_text(text: str, width: int) -> str:
    """Wrap text to specified width."""
    words = text.split()
    lines = []
    current_line = []
    current_length = 0
    
    for word in words:
        if current_length + len(word) + 1 > width:
            if current_line:
                lines.append(' '.join(current_line))
                current_line = [word]
                current_length = len(word)
            else:
                lines.append(word)
                current_length = 0
        else:
            current_line.append(word)
            current_length += len(word) + 1
    
    if current_line:
        lines.append(' '.join(current_line))
    
    return '\n'.join(lines) + '\n'


def _get_move_description(move_str: str) -> str:
    """Get description for a move."""
    descriptions = {
        'R': "Right face clockwise 90°",
        "R'": "Right face counter-clockwise 90°",
        'R2': "Right face 180°",
        'L': "Left face clockwise 90°",
        "L'": "Left face counter-clockwise 90°",
        'L2': "Left face 180°",
        'U': "Up face clockwise 90°",
        "U'": "Up face counter-clockwise 90°",
        'U2': "Up face 180°",
        'D': "Down face clockwise 90°",
        "D'": "Down face counter-clockwise 90°",
        'D2': "Down face 180°",
        'F': "Front face clockwise 90°",
        "F'": "Front face counter-clockwise 90°",
        'F2': "Front face 180°",
        'B': "Back face clockwise 90°",
        "B'": "Back face counter-clockwise 90°",
        'B2': "Back face 180°",
    }
    
    return descriptions.get(move_str, "Unknown move")


def _analyze_moves(sequence: MoveSequence) -> Dict[str, Any]:
    """Analyze move sequence for statistics."""
    if len(sequence) == 0:
        return {
            'face_counts': {},
            'quarter_turns': 0,
            'half_turns': 0
        }
    
    face_counts = {}
    quarter_turns = 0
    half_turns = 0
    
    for move in sequence:
        move_str = str(move)
        face = move_str[0]
        
        face_counts[face] = face_counts.get(face, 0) + 1
        
        if '2' in move_str:
            half_turns += 1
        else:
            quarter_turns += 1
    
    return {
        'face_counts': face_counts,
        'quarter_turns': quarter_turns,
        'half_turns': half_turns
    }


def _rate_efficiency(move_count: int) -> str:
    """Rate the efficiency of the solution."""
    if move_count <= 20:
        return "Excellent (Optimal)"
    elif move_count <= 30:
        return "Very Good (Advanced)"
    elif move_count <= 50:
        return "Good (Intermediate)"
    elif move_count <= 80:
        return "Average (Beginner)"
    else:
        return "Needs Improvement"


def _rate_speed(tps: float) -> str:
    """Rate the execution speed."""
    if tps >= 3.0:
        return "Very Fast"
    elif tps >= 2.0:
        return "Fast"
    elif tps >= 1.0:
        return "Moderate"
    elif tps >= 0.5:
        return "Slow"
    else:
        return "Very Slow"


def _overall_rating(move_count: int, tps: float) -> str:
    """Calculate overall performance rating."""
    efficiency_score = 0
    speed_score = 0
    
    # Efficiency scoring
    if move_count <= 20:
        efficiency_score = 5
    elif move_count <= 30:
        efficiency_score = 4
    elif move_count <= 50:
        efficiency_score = 3
    elif move_count <= 80:
        efficiency_score = 2
    else:
        efficiency_score = 1
    
    # Speed scoring
    if tps >= 3.0:
        speed_score = 5
    elif tps >= 2.0:
        speed_score = 4
    elif tps >= 1.0:
        speed_score = 3
    elif tps >= 0.5:
        speed_score = 2
    else:
        speed_score = 1
    
    # Combined rating
    total_score = (efficiency_score + speed_score) / 2
    
    if total_score >= 4.5:
        return "★★★★★ Excellent"
    elif total_score >= 3.5:
        return "★★★★☆ Very Good"
    elif total_score >= 2.5:
        return "★★★☆☆ Good"
    elif total_score >= 1.5:
        return "★★☆☆☆ Fair"
    else:
        return "★☆☆☆☆ Needs Work"


def export_simple_moves(filename: str, sequence: MoveSequence) -> None:
    """
    Export just the move sequence in simple format.
    
    Args:
        filename: Output filename
        sequence: Move sequence to export
    """
    with open(filename, 'w', encoding='utf-8') as f:
        if len(sequence) == 0:
            f.write("No moves - cube is solved\n")
        else:
            f.write(str(sequence) + "\n")


def export_scramble_format(filename: str, sequence: MoveSequence) -> None:
    """
    Export in standard scramble format.
    
    Args:
        filename: Output filename
        sequence: Move sequence to export
    """
    with open(filename, 'w', encoding='utf-8') as f:
        f.write("Scramble: " + str(sequence) + "\n")


def export_detailed_log(filename: str, solve_data: Dict[str, Any]) -> None:
    """
    Export detailed solve log with timestamps.
    
    Args:
        filename: Output filename
        solve_data: Complete solve data
    """
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Solve started\n")
        f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Solver: {solve_data.get('solver', 'Unknown')}\n")
        f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Solution found: {len(solve_data.get('sequence', []))} moves\n")
        f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Moves: {solve_data.get('sequence', 'None')}\n")
        f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Solve completed\n")
